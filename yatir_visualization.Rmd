---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.3.2
  kernelspec:
    display_name: wrfhv_github
    language: python
    name: wrfhv_github
---

```{python ein.hycell=FALSE, ein.tags="worksheet-0", slideshow={'slide_type': '-'}}
import os
import numpy as np
import xarray as xr
import pandas as pd
import seaborn as sns
import holoviews as hv
import hvplot.xarray
from holoviews import opts
import geoviews as gv
import geoviews.feature as gf
import matplotlib.pyplot as plt
import cartopy.crs as ccrs

import panel as pn

import geoviews_tools as gt
from timutils.git_tools import print_cwd_git_version
```

```{python ein.hycell=FALSE, ein.tags="worksheet-0", slideshow={'slide_type': '-'}}
print('git: ', end='')
print_cwd_git_version()
gv.extension('matplotlib')
pn.extension() # enable panel to connect to jupyter notebook
```

# Yatir Parameterizaton WRF results

A collection of plots showing WRF-simulated surface energy and carbon fluxes for two different simulations of Yatir Forest in Israel.  The first WRF run is a control run using 'out of the box' NOAH-MP land surface parameterizations derived from MODIS land cover types.  The second WRF run is an experimental run that set a 15-km radius surrounding Yatir Forest to a lower albedo and higher surface roughness length relative to both the open shrubland PFT that occupies the area in the control run as well as the desert surrounding the forest.

```{python}
ctlday, ytrday, ctl_minus_ytr = gt.merge_yatir_fluxes_landuse(
    fname_ctl='ctl_d03_postprocessed.nc',
    fname_yatir='ytr_d03_postprocessed.nc')
```

```{python}
#define some holoviews dimensions
dims = gt.define_dims(ctlday)
# provide a default value for time dimension; this determines initial slider position
dims['hour'] = hv.Dimension('hour', label='hour of day', unit='UTC', default=9)
dims['time'] = hv.Dimension('time', label='date', unit='y/m/d')
dims['area'] =  hv.Dimension('area', 
                             label='parameterization', 
                             values=['Yatir cells', 'Desert cells'])
dims['WRFrun'] = hv.Dimension('WRFrun', 
                              label='WRF run',
                              values=['Yatir WRF run', 'Control WRF run'])
```

```{python}
ds_diff = xr.concat([ctlday, ytrday, ctl_minus_ytr], 
                    dim=pd.Index(['control', 'yatir', 'control - Yatir'], name='WRFrun'))
```

```{python}
ds_diff = ds_diff.assign_coords({'bottom_top_stag': np.arange(ds_diff.dims['bottom_top_stag'])})
ds_diff = ds_diff.assign_coords({'bottom_top': np.arange(ds_diff.dims['bottom_top'])})
```

```{python}
yatir_idx = 21  # list(ds_diff['PFT'].values).index('Yatir')  
ds_diff = ds_diff.assign(yatir_mask=ds_diff.sel(WRFrun='yatir')['LU_INDEX'] == yatir_idx)
```

```{python}
dim_WRFrun = hv.Dimension('WRFrun', label='WRF run')
ds = {(WRFrun, var): gv.Dataset(ds_diff.sel(WRFrun=WRFrun)[var], 
                                kdims=[dims['hour'], dims['lon'], dims['lat']], 
                                vdims=[dims[var]])
       for WRFrun in list(ds_diff.WRFrun.values)
       for var in ['theta', 'height', 'height_agl', 'W', 'T', 'SWDOWN', 'HFX', 'LH', 'GPP', 'FVEG', 'FSA', 'FIRA', 'RSSUN', 'RSSHA']}
# need to skip the two landuse variables in creating the dict because they do not have an 'hours' dimension
```

```{python}
def get_cmaps():
    """define colormaps by WRFrun and variable
    
    WRF runs: ['control', 'yatir, 'control - Yatir']
    variables: ['GPP', 'LH', 'HFX', 'FVEG', 'SWDOWN', 'FSA', 'FIRA']
    
    sets a sequential colormap for each variable 
    for yatir and control runs and a diverging
    colormap for the control - Yatir difference
    """
    var_cmaps = {'GPP': 'Greens',
                'LH': 'Blues',
                'HFX': 'Reds',
                'FVEG': 'Greens',
                'SWDOWN': 'YlOrRd',
                'FSA': 'YlOrRd',
                'FIRA': 'YlOrRd',
                'W': 'PuOr',
                'T': 'coolwarm',
                'theta': 'coolwarm',
                'height_agl': 'terrain'}
    cmaps = {}
    for k, v in var_cmaps.items():
        for run in ['control', 'yatir', 'control - Yatir']:
            if run in ['control', 'yatir']:
                cmaps[(k, run)] = var_cmaps[k]
            else:
                cmaps[(k, run)] = 'BrBG'
    return(cmaps)       
```

```{python}
def make_var_layout(ds, varname, ncols=2):
    """make HoloViews layout showing Yatir, Control, and control - Yatir
    """
    this_min = {k: v.data.to_array().values.min() for k, v in ds.items()}
    this_max = {k: v.data.to_array().values.max() for k, v in ds.items()}
    this_absmax = {k: np.abs(v.data.to_array().values).max() for k, v in ds.items()}
    clims = {'control': (min(this_min['control', varname],
                             this_min['yatir', varname]),
                         max(this_max['control', varname],
                             this_max['yatir', varname])),
             'control - Yatir': (this_absmax['control - Yatir', varname] * -1.0,
                            this_absmax['control - Yatir', varname])}
    clims['yatir'] = clims['control']
             
    cbar_sym = {'control': False,
                'yatir': False,
                'control - Yatir': True}
    #TODO: adjust the colorscale limits for the control - Yatir plot
    #TODO: use a diverging colormap for the control - Yatir plots
    var_layout = hv.Layout([ds[WRFrun, varname].to(gv.QuadMesh, 
                            kdims=[dims['lon'], dims['lat']], 
                            vdims=varname,
                            dynamic=True).opts(colorbar=True, 
                                                padding=0.1,
                                                clim=clims[WRFrun],
                                                cmap=get_cmaps()[varname, WRFrun],
                                                title=WRFrun,
                                                projection=ccrs.PlateCarree())
                             for WRFrun in ['control', 'yatir', 'control - Yatir']]).cols(
        ncols).opts(title=dims[varname].label)
    layout_with_map = var_layout * gf.borders(scale='50m') * gf.coastline(scale='50m')# * gf.ocean(scale='50m')
    return(layout_with_map)
```

Show vegetation fraction output by WRF for the control run and Yatir parameterization run.  *Finally* WRF is setting the vegetation fraction for Yatir Forest to 0.40.  I chose 0.40 to match the (approximate) most densly vegetated pixels in this region in the MODIS data ('control' panel below).

```{python}
this_layout = hv.Layout([gv.Dataset(ds.sel(hour=10), # hour is arbitrary for vegetation fraction
                      kdims=[dims['lon'], dims['lat']]).to(gv.QuadMesh, 
                                          kdims=[dims['lon'], dims['lat']], 
                                          vdims=dims['FVEG']).opts(cmap=get_cmaps()['FVEG', 
                                                                                    'control'], 
                                                                   colorbar=True,
                                                                   title=label,
                                                                   projection=ccrs.PlateCarree())
           for label, ds in dict(zip(['control', 'Yatir'], [ctlday, ytrday])).items()]).opts(
    title=dims['FVEG'].label)
this_layout * gf.borders(scale='50m') * gf.coastline(scale='50m') #* gf.ocean(scale='50m')
```

The plots show surface energy and carbon fluxes simulated by WRF for the control run, the Yatir parameterization run, and the control - Yatir between the two runs for daylight hours.  The runs constrast more now that the vegetation fraction problem is fixed.

```{python}
#holoviews triggers a matplotlib deprecation warning that prints out a million 
# times per plot; disable warmings for the time being.
import warnings
warnings.filterwarnings('ignore')
```

```{python}
make_var_layout(ds, 'SWDOWN')
```

```{python}
make_var_layout(ds, 'FSA')
```

```{python}
make_var_layout(ds, 'FIRA')
```

```{python}
make_var_layout(ds, 'HFX')
```

```{python}
make_var_layout(ds, 'LH')
```

```{python}
def get_vdim(ds, varname):
    """find the name of the vertical dimension for an xarray variable 
    """
    vertical_dim = [d for d in ds[varname].dims if 'bottom_top' in d]
    if any(vertical_dim):
        if len(vertical_dim) > 1:
            raise(ValueError('{} has more than one '
                             'vertical dimension'.format(this_var)))
        else:
            vertical_dim = vertical_dim[0]
    return(vertical_dim)
```

```{python}
gt.three_panel_quadmesh_compare(ds_diff)
```

# WRF domain setup


<img src="./yatir_show_dom.pdf" width=900/>

<!-- #region ein.tags="worksheet-0" slideshow={"slide_type": "-"} -->
# Yatir parameterization #
<!-- #endregion -->

<!-- #region ein.tags="worksheet-0" slideshow={"slide_type": "-"} -->
# Sensible Heat #
<!-- #endregion -->

<!-- #region ein.tags="worksheet-0" slideshow={"slide_type": "-"} -->
Yatir sensible heat flux in late August 2015 was 368.8 to 434.4 W m$^{-2}$ ([Brugger et al 2018](https://doi.org/10.1007/s10546-018-0371-5). Table 3).  There was a strong diurnal cycle for both sites (forest and desert).  Note the figure units are K m s$^{-1}$.  Figure from [Banerjee et al, 2018]([www.atmos-chem-phys.net/18/10025/2018/).
            <img src="./Banergee_etal_ACP_2018_fig3.pdf" width=900/>
<!-- #endregion -->

```{python}
is_yatir = ds_diff.yatir_mask
is_desert = np.logical_not(is_yatir)
is_desert_veg = is_desert & (ds_diff.FVEG > 0.01)
is_desert_bare = is_desert & (ds_diff.FVEG < 0.01)
means = xr.concat([ds_diff.where(mask).mean(dim=['south_north', 'west_east'])
                   for mask in [is_yatir, is_desert, is_desert_veg, is_desert_bare]],
                  dim=pd.Index(['yatir', 'desert', 'desert vegetated', 'desert bare'], name='area'))
plots = hv.Dataset(means['HFX']).to(hv.Curve, kdims='hour').opts(xlim=(0, 24))
plots.overlay('WRFrun').layout('area').cols(2)
```

Parse Yatir Forest eddy covariance data

```{python}
hv.extension('bokeh')
```

```{python}
df_ytr = gt.parse_yatir_EC_observations()
# make Yatir Fluxnet variable names match WRF variable names
df_ytr = df_ytr.rename(columns={'H': 'HFX',
                                'LE': 'LH',
                               'SW_IN': 'SWDOWN',
                               'FC': 'GPP',
                               'NETRAD': 'FIRA'})
hv_ytr = hv.Table(df_ytr)
cv_obs = [hv_ytr.to.curve('time', dims[this_var], [], label='Yatir observed').opts(width=600)
          for this_var in ['HFX', 'LH', 'SWDOWN', 'FIRA']]

```

#### Yatir Fluxnet observations

```{python}
# demonstrate that hv.Layout(cv_obs) skips a plot?!?!?!?!?
# foo = cv_obs[0] + cv_obs[1] + cv_obs[2] + cv_obs[3]
# print(foo)
# bar = hv.Layout([c for c in cv_obs])
# print(bar)
# print((len(cv_obs)))
# print(len([c for c in cv_obs]))
```

```{python}
hv.Layout(cv_obs[0] + cv_obs[1] + cv_obs[2] + cv_obs[3]).cols(1)
```

```{python}
# calculate hour mean Yatir Fluxnet observations and place in xarray dataset alongside WRF output
var_list = ['HFX', 'LH', 'SWDOWN', 'FIRA', 'hour']
obs_mean = df_ytr[var_list].groupby('hour').mean()
```

#### Yatir observations overlaid on WRF results, mean daily cycle 15-19 Aug 2015
"area: desert" shows mean daily cycle of WRF desert cells only<BR>
"area: yatir"  shows mean daily cycle of WRF Yatir-parameterized cells only

```{python}
gt.daily_cycle_mean_overlay_layout(obs_mean, means, 'HFX')
```

```{python}
gt.daily_cycle_mean_overlay_layout(obs_mean, means, 'LH')
```

```{python}
gt.daily_cycle_mean_overlay_layout(obs_mean, means, 'SWDOWN')
```

"FIRA" (completely counter to intuitiion) abbreviates "total net longwave rad"

```{python}
gt.daily_cycle_mean_overlay_layout(obs_mean, means, 'FIRA')
```

WRF-NOAHMP simulated stomatal resistance, sunlit and shaded (s/m)

```{python}
plots = hv.Dataset(means['RSSUN']).to(hv.Curve, kdims='hour').opts(xlim=(0, 24))
plots.overlay('WRFrun').layout('area').cols(2)
```

```{python}
plots = hv.Dataset(means['RSSHA']).to(hv.Curve, kdims='hour').opts(xlim=(0, 24))
plots.overlay('WRFrun').layout('area').cols(2)
```

```{python ein.hycell=FALSE, ein.tags="worksheet-0", slideshow={'slide_type': '-'}}
# hv.extension('bokeh')
# hfx_dim_zoomed = hv.Dimension('HFX_zoomed', label='sensible heat flux', unit='W m-2')
# def two_panel_energy_flux_plot(ds, obs, t_str=""):
#     """make a plot of Yatir surface energy fluxes"""
#     gvds = gv.Dataset(ds, kdims=['WRFrun',  'time', 'x', 'y'])
#     WRF_run_labels = ds['WRFrun'].values
#     line_styles = ['solid', 'dashed']
#     cv = [hv.Curve(gvds.reduce(['x', 'y'], 
#                                function=np.nanmean).select(WRFrun=this_run), 
#                    t_dim, this_v_dim,
#                    label=this_run).opts(opts.Curve(line_dash=this_linestyle, line_width=1))
#           for this_run, this_linestyle, this_v_dim in zip(WRF_run_labels, 
#                                                           line_styles, 
#                                                          [hfx_dim, hfx_dim_zoomed])]
#     overlay_opts=opts.Overlay(frame_width=690, 
#                               legend_position='right', 
#                               ylim=(0, 450),
#                              title_format=t_str)
#     cv_hfx = hv.Overlay(cv).opts(overlay_opts)
#     overlay_opts=opts.Overlay(frame_width=690, legend_position='right', ylim=(350, 450))
#     cv_hfx_zoomed = hv.Overlay(cv).opts(overlay_opts)
#     hvly = hv.Layout([cv_hfx, cv_hfx_zoomed]).cols(1).opts(norm={'axiswise': True})
#     return(hvly, cv_hfx, cv_hfx_zoomed)
```

[Brugger et al (2018)](https://doi.org/10.1007/s10546-018-0371-5).  Question from Michael - why are the units W m$^{-1}$ and not W m$^{-2}$?
<img src="./brugger_etal_2018_table3.jpg" width=900/>
